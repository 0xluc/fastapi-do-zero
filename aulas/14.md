# Projeto final

VocÃª chegou ao final, [PARABAINS](https://youtu.be/1Mcdh2Vf2Xk){:target="_blank"} ðŸŽ‰

No aprendizado, nada melhor que praticar! Para isso vamos fazer nosso "TCC". A ideia do projeto Ã© simplesmente para fixaÃ§Ã£o do conteÃºdo.

## O projeto

Neste projeto vamos construir uma API que segue os mesmos moldes da que desenvolvemos durante o curso, porÃ©m, com outra proposta. Iremos fazer uma versÃ£o simplificado de um acervo digital de livros. Chamaremos de `MADR` (Mader), uma sigla para "Meu Acervo Digital de Romances".

O objetivo do projeto Ã© criarmos uma gerenciador de livros e relacionar com seus autores. Tudo isso em um contexto bastante simplificado. Usando somente as funcionalidades que aprendemos no curso.

A implementaÃ§Ã£o serÃ¡ baseada em 3 pilares:

```mermaid
graph
    MADL --> A["Controle de acesso / Gerenciamento de contas"]
	MADL --> B["Gerenciamento de Livros"]
	MADL --> C["Gerenciamento de Romancistas"]
	A --> D["Gerenciamento de contas"]
	D --> CriaÃ§Ã£o
	D --> AtualizaÃ§Ã£o
	A --> G["Acesso via JWT"]
	D --> DeleÃ§Ã£o
	B --> E["CRUD"]
	C --> F["CRUD"]
```

### A API

Dividiremos os endpoits em trÃªs `routers`:

1. `contas`: Gerenciamento de contas e de acesso a API
2. `livros`: Gerenciamento de livros
3. `romancistas`: Gerenciamento de romancistas

#### Contas

O router de conta deve ser responsÃ¡vel pelas operaÃ§Ãµes referentes a criaÃ§Ã£o, alteraÃ§Ã£o e deleÃ§Ã£o de contas. Os endpoints:

- POST `/conta`: deve ser responsÃ¡vel pela criaÃ§Ã£o de uma nova conta
  
    - O schema responsÃ¡vel para criaÃ§Ã£o desse endpoint deve ser:
    ```json
    {
        "username": "fausto",
        "email": "fausto@fausto.com",
        "senha": "1234567",
    }
    ```
	- Esses schema deve ser validado com pydantic
	- O retorno para o caso de sucesso deve ser `201` e com o schema de exemplo:
	```json
	{
	    "id": 10,
		"email": "fausto@fausto.com",
		"username": "fausto"
	}
	```
	- A senha deve ser criptografada antes de ser inserida no banco de dados
	- obs: **NÃ£o Ã© necessÃ¡rio** fazer o login no sistema para enviar uma requisiÃ§Ã£o para esse enpoint
	- Em um caso onde algum campo da conta jÃ¡ esteja registrado na conta, deve-se retornar `400 BAD REQUEST` com o json
	```json
	{
	    "message": "Conta jÃ¡ cadastrada"
	}
	```

- PUT `/conta/{id}`: deve ser responsÃ¡vel pela alteraÃ§Ã£o de uma conta especificada por `id`
    - O schema responsÃ¡vel para criaÃ§Ã£o desse endpoint deve ser:
    ```json
    {
        "username": "fausto",
        "email": "fausto@fausto.com",
        "senha": "1234567",
    }
    ```
	- Esses schema deve ser validado com pydantic
	- O retorno para o caso de sucesso deve ser `200` e com o schema de exemplo:
	```json
	{
	    "id": 10,
		"email": "fausto@fausto.com",
		"username": "fausto"
	}
	```
	- ðŸš¨ O acesso sÃ³ pode ocorrer via um `Bearer token` vÃ¡lido enviado nos headers, [erro](#erros)
	- ðŸš¨ Somente a pessoa detentora da sua prÃ³pria conta conta pode alterar seus dados

- DELETE `/conta{id}`: deve ser responsÃ¡vel pela deleÃ§Ã£o de uma conta especificada por `id`
    - O retorno para o caso de sucesso deve ser `200` e com o schema de exemplo:
	```json
	{
		"message": "Conta deletada com sucesso",
	}
	```
	- ðŸš¨ O acesso sÃ³ pode ocorrer via um `Bearer token` vÃ¡lido enviado nos headers, [erro](#erros)
	- ðŸš¨ Somente a pessoa detentora da sua prÃ³pria conta conta pode alterar seus dados
	- ðŸš¨ TODO: CASO DE ERRO

- POST `/token`: ResponsÃ¡vel pelo login
    - O endpoint deverÃ¡ receber o seguinte schema via `OAuth2PasswordRequestForm`:
	```json
	{
	    "username": "fausto@fausto.com",
		"password": "12345"
	}
	```
	- O conta deve ser validada com "username" e "password"
	- ðŸš¨ O acesso sÃ³ pode ocorrer via um `Bearer token` vÃ¡lido enviado nos headers, [erro](#erros)
    - O retorno para o caso de sucesso deve ser `200` e com o schema de exemplo:
	```json
	{
		"access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0ZUB0ZXN0LmNvbSIsImV4cCI6MTY5MDI1ODE1M30.Nx0P_ornVwJBH_LLLVrlJoh6RmJeXR-Nr7YJ_mlGY04",
		"token_type": "bearer"
	}
	```

- POST `/refresh-token`: ResponsÃ¡vel por atualizar o token
    - O endpoint deverÃ¡ receber os headers:
	```json
	{
		"Authorization": " Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0ZUB0ZXN0LmNvbSIsImV4cCI6MTY5MDI1ODE1M30.Nx0P_ornVwJBH_LLLVrlJoh6RmJeXR-Nr7YJ_mlGY04"
	}
	```
    - O retorno para o caso de sucesso deve ser `200` e com o schema de exemplo:
	```json
	{
		"access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0ZUB0ZXN0LmNvbSIsImV4cCI6MTY5MDI1ODE1M30.Nx0P_ornVwJBH_LLLVrlJoh6RmJeXR-Nr7YJ_mlGY04",
		"token_type": "bearer"
	}
	```
	- ðŸš¨ Caso as coisas nÃ£o ocorram como o esperado: [Erros](#erros)
	
##### As condiÃ§Ãµes do token JWT

O tempo de expiraÃ§Ã£o do token deve ser de `60` minutos, o algorÃ­timo usado deve ser `HS256` e o subject deve ser o `email`.

#### livros

#### romancistas

### Erros

##### Erros de autenticaÃ§Ã£o

Todos os erros relativos a autenticaÃ§Ã£o devem retornar o status code `400 BAD REQUEST` com o seguinte schema:

```json
{
    "message": "Email ou senha incorretos"
}
```

##### Erros de permissÃ£o

Caso uma pessoa tente fazer uma operaÃ§Ã£o sem a permissÃ£o necessÃ¡ria, o status code`401 Unauthorized` deverÃ¡ ser retornado com o json:

```json
{
    "message": "NÃ£o autorizado"
}
```

### O banco de dados / ORM

TrÃªs tabelas devem ser criadas, `User`, `Livro` e `Autoria`. Onde `Livro` e `Autoria` se relacionam da forma que um autor pode estar relacionado a diversos livros e diversos livros devem ser associados a um Ãºnico altor. Como sugere o [DER](https://pt.wikipedia.org/wiki/Modelo_entidade_relacionamento){:target="_blank"}:

```mermaid
erDiagram
  Autoria |o -- |{ Livro : livros
  User {
      int id PK
      string email UK
	  string username UK
	  string senha
  }
  Livro {
	  int id  PK
	  string ano
	  string titulo UK
      string id_autoria FK
  }
  Autoria {
      int id PK
      string nome UK
	  string livros
  }
```

### Relacionamentos no ORM

```python
class Livro:
	...
    
	autoria: Mapped['Autoria'] = relationship(
        init=False, back_populates='livros'
    )

class Autoria:
	...

    livros: Mapped[list['Livro']] = relationship(
        init=False, back_populates='autoria', cascade='all, delete-orphan'
    )
```

## Entidades

### User

- username
- email
- senha

#### mÃ©todos

- Login (JWT)
- Create (POST - 201)
- update (PATCH - 200)
  - loggin_required
  - identidade
- delete (DELETE - 200)
  - loggin_required
  - identidade

### Livro

- Autoria (relacionamento) [Livros sÃ³ podem ter uma pessoa relacionada!]
- TÃ­tulo
- Ano

#### Filtros de busca

- Autoria
  - fullmatch
  - match parcial
  
- tÃ­tulo
  - fullmatch
  - match parcial
  
- Ano
  - fullmatch
  
#### mÃ©todos

- Criar (POST - 201)
  - back populate (autoria vem junto) [opcional]
  - loggin_required
- Alterar {ID} (PUT - 200)
  - Age como POST
  - loggin_required
- Deletar {ID} (DELETE - 204)
  - loggin_required
- Recuperar genÃ©rico (GET - 200)
  - queryparams
	- nome?
	- ano?
	- autoria?
  - PaginaÃ§Ã£o (limit, offset)
- Recuperar {ID} (GET - 200)
  - PaginaÃ§Ã£o (limit, offset)


### Autoria

- Nome
- livros publicados (relacionamento)

#### Filtros

- nome
  - fullmatch
  - match parcial

#### mÃ©todos

- Criar (POST - 201)
  - loggin_required
- Alterar {ID} (PATCH - 200)
  - loggin_required
- Deletar {ID} (DELETE - 204)
  - loggin_required
- Recuperar {ID} (GET - 200)
  - queryparams
	- livros ou nÃ£o
- Recuperar por Nome (GET - 200)
  - PaginaÃ§Ã£o (limit, offset)
  - sem livros


## CenÃ¡rios de teste

### Gerenciamento de contas

=== "CriaÃ§Ã£o de contas"
	```gherkin
	Funcionalidade: Gerenciamento de conta

	CenÃ¡rio: CriaÃ§Ã£o de conta
		Quando enviar um "POST" em "/user"
		"""
		{
			"username": "dunossauro",
			"email": "dudu@dudu.com",
			"password": "123456"
		}
		"""
		EntÃ£o devo receber o status "201"
		E o json contendo
		"""
		{
			"email": "dudu@dudu.com",
			"username": "dunossauro"
		}
		"""

	CenÃ¡rio: CriaÃ§Ã£o de conta jÃ¡ existente
		Quando enviar um "POST" em "/user"
		"""
		{
			"username": "dunossauro",
			"email": "dudu@dudu.com",
			"password": "123456"
		}
		"""
		Quando enviar um "POST" em "/user"
		"""
		{
			"username": "dunossauro",
			"email": "dudu@dudu.com",
			"password": "123456"
		}
		"""
		EntÃ£o devo receber o status "400"
		E o json contendo
		"""
		{
			"message": "Conta jÃ¡ cadastrada"
		}
		"""

	CenÃ¡rio: AlteraÃ§Ã£o de conta
		Quando enviar um "POST" em "/user"
		"""
		{
			"username": "dunossauro",
			"email": "dudu@dudu.com",
			"password": "123456"
		}
		"""
		Quando enviar um "PUT" em "/user/1"
		"""
		{
			"username": "dunossauro",
			"email": "dudu@dudu.com",
			"password": "654321"
		}
		"""
		EntÃ£o devo receber o status "200"
		E o json contendo
		"""
		{
			"username": "dunossauro",
			"email": "dudu@dudu.com"
		}
		"""

	CenÃ¡rio: DeleÃ§Ã£o da conta
		Quando enviar um "POST" em "/user"
		"""
		{
			"username": "dunossauro",
			"email": "dudu@dudu.com",
			"password": "123456"
		}
		"""
		Quando enviar um "DELETE" em "/user/1"
		EntÃ£o devo receber o status "200"
		E o json contendo
		"""
		{
			"message": "Conta deletada com sucesso",
		}
		"""
	```

=== "AutenticaÃ§Ã£o e autorizaÃ§Ã£o"
	> TODO!
