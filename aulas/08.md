---
title: Tornando o projeto assíncrono
description: Adicionando assyncio ao nosso projeto
---

# [WIP] Tornando o projeto assíncrono

Objetivos dessa aula:

- Introduzir os conceitos de programação assíncrona
- Refatorar nossa aplicação para suportar asyncio

{%set aula = "08" %}
{%set link = "nGqvdJ4Z-iA" %}
{% include "templates/cabecalho.md" %}

---

Uma das características mais apreciadas do FastAPI é o suporte a programação assíncrona. Isso nos permite usar concorrência nos momentos de entrada e saída, fazendo com que enquanto buscamos por um dado no banco dedados, por exemplo, o nosso aplicativo esteja disponível para receber e também responder novas requisições.

## [NF] Uma pequena introdução ao asyncio

> Falar sobre o loop de eventos, introduzir o conceito de cooperação e falar sobre escalonamento

## Sqlalchemy não bloqueante

> Introdução

Embora o SQLAlchemy suporte asyncio, o sqlite, banco que usamos até o momento, não suporta asyncio na implementação nativa do python. Para isso, temos instalar uma extensão chamada `aiosqlite`. Isso vai nos dar a opção de manusear o banco de dados em um único arquivo, de forma assíncrona:

```bash title="$ Execução no terminal!"
poetry add aiosqlite
```

Para que nossa conexão esteja ciente que o `aiosqlite` está sendo usado, devemos alterar a variável de ambiente para contemplar essa alteração:

```bash title=".env"
DATABASE_URL="sqlite+aiosqlite:///database.db"
```

Embora isso pareça o suficiente, nossa `Sessão` do banco de dados ainda não está preparada para lidar com uma conexão assíncrona. Isso quer dizer que precisamos alterar a forma como ela é criada e deixar explícito que agora vamos fazer uma conexão assíncrona:

```python title="fast_zero/database.py"
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine

from fast_zero.settings import Settings

engine = create_async_engine(Settings().DATABASE_URL)#(1)!


async def get_session():
    async with AsyncSession(engine, expire_on_commit=False) as session: #(2)!
        yield session
```

1. a
2. b

Agora todo I/O que acontece no banco pode ser assíncrono, isso em potencial. Mas precisamos adequar nosso código para que o escalonamento entre tarefas possa ser feito.

??? note "Expiração do commit"
    > TODO!
	https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html#preventing-implicit-io-when-using-asyncsession

#### Ajustando a sessão de testes

Embora o SQLAlchemy e o FastAPI lidem de forma nativa com programação assíncrona, o `pytest` ainda não. Para isso precisamos instalar uma extensão que adicione esse suporte. A `pytest-asyncio`:

```bash title="$ Execução no terminal!"
poetry add --group dev pytest-asyncio
```

Essa extensão vai adicionar duas coisas importantes ao pytest, a oportunidade de criar fixtures assíncronas e testes assíncronos.

Vamos ajustar a nossa fixture de `session` para utilizar asyncio:

```python title="tests/conftest.py" hl_lines="3 4 8 9 11 15 16 18"
# ...

import pytest_asyncio
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine

# ...

@pytest_asyncio.fixture#(1)!
async def session():
    engine = create_async_engine(
        'sqlite+aiosqlite:///:memory:',
        connect_args={'check_same_thread': False},
        poolclass=StaticPool,
    )
    async with engine.begin() as conn:#(2)!
        await conn.run_sync(table_registry.metadata.create_all)#(3)!

    async with AsyncSession(engine, expire_on_commit=False) as session:#(4)!
        yield session

    async with engine.begin() as conn:
        await conn.run_sync(table_registry.metadata.drop_all)
```

1. a
2. b
3. c
4. d


### Ajustando o teste do banco de dados

```python title="testes/test_db.py" hl_lines="3 9 10 16 18"
from dataclasses import asdict

import pytest
from sqlalchemy import select

from fast_zero.models import User


@pytest.mark.asyncio #(1)!
async def test_create_user(session, mock_db_time):
    with mock_db_time(model=User) as time:
        new_user = User(
            username='alice', password='secret', email='teste@test'
        )
        session.add(new_user)
        await session.commit() #(2)!

    user = await session.scalar(select(User).where(User.username == 'alice')) #(3)!

    assert asdict(user) == {
        'id': 1,
        'username': 'alice',
        'password': 'secret',
        'email': 'teste@test',
        'created_at': time,
    }
```

1. Essa marcação, diz ao pytest que esse teste contém código assíncrono
2. Como `.commit` faz uma chamada ao banco de dados é categorizada como I/O. Logo, essa chamada pode escalonar o async, então usamos `await`
3. Outra chamada que depende de I/O, a chamada no banco espera a consulta ser concluída, logo, também usamos `await`.

Executando o teste:

```shell title="$ Execução no terminal!"
task test tests/test_db.py

# ...
tests/test_db.py::test_create_user PASSED
```



## Endpoints não bloqueantes

Para que os endpoints não sejam bloqueantes, a primeira coisa a se fazer é adicionar a palavra reservada `#!python async` no inicio de todos eles.

A estratégia que vamos usar aqui é a de andar um teste por vez. Uma das funcionalidades legais do pytest é poder executar somente um único teste. Para isso podemos passar o nome do arquivo, seguido de `::` e o nome do teste como parâmetro. Algo como:

```shell title="$ Execução no terminal!"
task test tests/test_users.py::test_create_user
```

### Router `auth`

```python title="fast_zero/routers/auth.py" hl_lines="6 11 12"
# ...
from sqlalchemy.ext.asyncio import AsyncSession

# ...

Session = Annotated[AsyncSession, Depends(get_session)]#(1)!

# ...

@router.post('/token', response_model=Token)
async def login_for_access_token(form_data: OAuth2Form, session: Session): #(2)!
    user = await session.scalar( #(3)!
        select(User).where(User.email == form_data.username)
    )
	
	# ...
```

1. a
2. b
3. c

### Router `users`

Vamos começar pelo cabeçalho do arquivo:

```python title="fast_zero/routers/users.py"
# ...
from sqlalchemy.ext.asyncio import AsyncSession

# ...

Session = Annotated[AsyncSession, Depends(get_session)]#(1)!

# ...
```

#### Endpoint de POST

```python title="fast_zero/routers/users.py"
@router.post('/', status_code=HTTPStatus.CREATED, response_model=UserPublic)
async def create_user(user: UserSchema, session: Session):
    db_user = await session.scalar(
        select(User).where(
            (User.username == user.username) | (User.email == user.email)
        )
    )
	# ...
	session.add(db_user)
    await session.commit()
    await session.refresh(db_user)

    return db_user
```

#### Endpoint de GET

```python title="fast_zero/routers/users.py"
@router.get('/', response_model=UserList)
async def read_users(
    session: Session, filter_users: Annotated[FilterPage, Query()]
):
    query = await session.scalars(
        select(User).offset(filter_users.offset).limit(filter_users.limit)
    )
    users = query.all()

    return {'users': users}
```

#### Endpoint de PUT

```python title="fast_zero/routers/users.py"
@router.put('/{user_id}', response_model=UserPublic)
async def update_user(
    user_id: int,
    user: UserSchema,
    session: Session,
    current_user: CurrentUser,
):
    # ...
    try:
        current_user.username = user.username
        current_user.password = get_password_hash(user.password)
        current_user.email = user.email
        await session.commit()
        await session.refresh(current_user)

        return current_user
    # ...
```

#### Endpoint de delete

```python title="fast_zero/routers/users.py"
@router.delete('/{user_id}', response_model=Message)
async def delete_user(
    user_id: int,
    session: Session,
    current_user: CurrentUser,
):
    # ...
    await session.delete(current_user)
    await session.commit()
```

## Commit

Para finalizar, criaremos um commit para registrar todas as alterações que fizemos na nossa aplicação. Como essa é uma grande mudança que envolve reestruturar a forma como lidamos com as rotas e mover as constantes para variáveis de ambiente, podemos usar uma mensagem de commit descritiva que explique todas as principais alterações:

```shell title="$ Execução no terminal!"
git add .
git commit -m "Refatorando estrutura do projeto: Suporte a asyncio, tornando o projeto não bloqueante"
```

## Exercícios

1. Reveja os endpoints criados por você em exercícios anteriores e adicione `#!python async` e `#!python await` para que eles se tornem não bloqueantes também.
2 ...

## Conclusão
