---
title: Estruturando o Projeto e Criando Rotas CRUD
description: Entendimento básico sobre API, HTTP, JSON e a estrutura do projeto
---

# Estruturando o Projeto e Criando Rotas CRUD

---

Objetivos dessa aula:

- Compreender a estrutura de um projeto FastAPI e como estruturar rotas CRUD (Criar, Ler, Atualizar, Deletar)
- Aprimorar nosso conhecimento sobre Pydantic e sua utilidade na validação e serialização de dados
- Implementação de rotas CRUD em FastAPI
- Escrita e execução de testes para validar o comportamento das rotas

??? tip "Caso prefira ver a aula em vídeo"
	Esse aula ainda não está disponível em formato de vídeo, somente em texto!

	![type:video](https://www.youtube.com/embed/u31qwQUeGuM)

[Aula :fontawesome-brands-youtube:](#){ .md-button }
[Slides :fontawesome-solid-file-powerpoint:](https://github.com/dunossauro/fastapi-do-zero/blob/main/slides/pdf/aula_03.pdf){ .md-button }
[Código :fontawesome-solid-code:](https://github.com/dunossauro/fast_zero/tree/03){ .md-button }

---

Boas-vindas de volta à nossa construção de uma aplicação usando FastAPI. Na última aula conversamos sobre alguns conceitos básicos do desenvolvimento WEB e terminamos de configurar nosso ambiente. Nesta aula, daremos um passo adiante ao estruturarmos os primeiros endpoints da nossa API, focando nas quatro operações básicas de gerenciamento de usuários. Vamos abordar o **CRUD** - Criar, Ler, Atualizar e Deletar - e como essas operações se aplicam tanto a comunicação web, quanto com o banco de dados.

Nosso objetivo nessa aula é implementar um sistema de cadastro de usuários para nossa aplicação. O objetivo é que possamos ao final dessa aula cadastrar, listar, alterar e deletar usuários da nossa aplicação com a aplicação de seus respectivos testes.

## CRUD e HTTP

No mundo do desenvolvimento de APIs, existem algumas operações básicas que gostaríamos de fazer com os dados. Essas operações se relacionam com a base de dados e a aplicação web. Vamos nos focar nesse primeiro momento nas relações entre os dados.

CRUD é um acrônimo que representa as quatro operações básicas que você pode realizar em qualquer banco de dados persistente:

- **C**reate (Criar): adicionar novos registros ao banco de dados.
- **R**ead (Ler): recuperar registros existentes do banco de dados. 
- **U**pdate (Atualizar): modificar registros existentes no banco de dados.
- **D**elete (Excluir): remover registros existentes do banco de dados.

Com essa operações podemos realizar qualquer tipo de comportamento dentro de uma base dados. Podemos criar um registro, em seguida altera-lo, quem sabe depois disso tudo deleta-lo.

Quando falamos de APIs servido dados, todas essa operações tem alguma forma similar dentro do protocolo HTTP. O protocolo tem verbos para indicar essas mesmas ações que queremos representar no banco de dados.

- **POST**: é usado para solicitar que o servidor aceite um dado (recurso) enviado pelo cliente.
- **GET**: é usado para quando o cliente deseja requisitar uma informação do servidor.
- **PUT**: é usando no momento em que o cliente deseja informar alguma alteração nos dados para o servidor.
- **DELETE**: usado para para dizer ao servidor que delete determinado recurso.

Dessa forma podemos criar associações entre os endpoints e a base de dados. Por exemplo: quando quisermos inserir um dado no banco de dados, nós como clientes devemos comunicar essa intenção ao servidor usando o método POST enviando os dados (em nosso caso no formato JSON) que devem ser persistidos na base de dados. Com isso iniciamos o processo de *create* na base de dados.

### Respostas da API

A forma de responder o cliente como as operações do CRUD se sucederam no servidor é via códigos de status. Por isso vamos investir mais algum momento aqui.

Os códigos que devemos prestar atenção para responder de forma correta as requisições. Os casos de sucesso incluem:

- **200 OK**: Para quando a requisição obteve sucesso.
    - **GET**: Quando pedidos um dado e ele é retornado com sucesso
	- **PUT**: Quando os dados são alterados com sucesso
- **201 CREATED**: O pedido foi atendido, resultando na criação de um novo recurso.
	- **POST**: Quando enviamos um dado e ele é criado com sucesso
	- **PUT**: Quando enviamos na alteração, mas ele não existia e foi criado
- **204 NO CONTENT**: Retorno do servidor sem conteúdo na mensagem
	- **PUT**: Se a alteração no banco não retornar nada
	- **DELETE**: Se o ato de deletar não retornar nada

Os códigos de erro mais comuns que temos que conhecer para lidar com possíveis erros na aplicação, são:

- **404 NOT FOUND**: O recurso solicitado não pôde ser encontrado.
- **422 UNPROCESSABLE ENTITY**: o pedido foi bem formado (ou seja, sintaticamente correto), mas não pôde ser processado.
- **500 INTERNAL SERVER ERROR**: Uma mensagem de erro genérica, dada quando uma condição inesperada foi encontrada. Geralmente ocorre quando nossa aplicação apresenta um erro.

Agora que temos uma ideia melhor do que vamos receber e cada ação que isso implicará. Podemos iniciar a escrita de alguns endpoints e aplicar todo esses conceitos na prática.

## Implementado endpoints

Acredito que para simplificar o aprendizado, podemos dividir a criação de qualquer novo endpoint em três partes:

1. Sua relação com o HTTP: qual verbo esperamos receber e quais códigos de resposta iremos retornar em caso de sucesso e erro.
2. Seus modelos de dados: qual o formato do JSON que esperamos receber? Quais os campos e quais seus tipos. Também é importante pensar no modelo de resposta. O que será retornado e qual situação. Qual o modelo de sucesso e qual o modelo de erro.
3. Implementação do corpo: o que vamos fazer com os dados recebidos, qual tipo de processamento será aplicado a ele.

As partes 1 e 2 me ajudam a definir a interface de comunicação e como isso ficará disponível na documentação. Já a terceira é uma escolha mais particular de como implementar, como chamaremos o banco de dados, existem mais validações a fazer? O que exatamente define o sucesso ou o erro nessa requisição?

Esses pequenos passos podem nos ajudar a não esquecer nada na hora da implementação do endpoint como um todo.


## Implementando a Rota POST

Como queremos fazer um cadastro de usuários nessa aula, a parte mais importante é que tenhamos uma forma de criar um novo usuário na base de dados.

O Verbo POST é comumente utilizado para informar o serviço que queremos enviar um dado. Nesse ponto todos os conceitos comumente se cruzam. Temos que ter um endpoint que aceite o verbo `POST` com dados (um JSON), que responda o status `201` como sucesso se o recurso for criado. Vamos iniciar por esse caminho e depois contemplaremos o que pode dar errado.

### Implementação do endpoint

Com o modelo definido podemos partir para criação do nosso endpoint. para que o endpoint receba requisições do verbo POST, podemos usar o mesmo formato do decorador do FastAPI, como `#!python @app.post()`.

Como o objetivo desse endpoint é criar usuários na base de dados, vamos iniciar sua URL com `#!python '/users/'`. Pois é onde receberemos dados para criá-los.

```python title="fast_zero/app.py" linenums="13"
@app.post('/users/')
def create_user():
	...
```

#### Status code de resposta

Temos que informar que quando nosso usuário for cadastrado com sucesso, retornará o código de resposta `201`. Para isso podemos passar o parâmetro `status_code` para o decorador:

```python title="fast_zero/app.py" linenums="13" hl_lines="1"
@app.post('/users/', status_code=201)
def create_user():
    ...
```

> Conversaremos em breve sobre o código de resposta em [TODO: tópico do pydantic]

### Modelo de dados

Para que os dados sejam enviados para nossa aplicação, devemos documentar o formato dos dados que esperamos receber. Para que quem use nossa aplicação saiba quais os campos e os dados que devem ser enviados. Da mesma forma em que é importante pensar e documentar no modelo de dados que será retornado ao cliente.

#### Modelo de entrada de dados

Vamos nos basear nesse modelo simples, onde precisamos de um nome de usuário `username`, o email no campo `email` e a senha no campo `password`. Isso será o suficiente para que um usuário se cadastre na nossa aplicação. Algo como:

```json
{
    "username": "joao123",
    "email": "joao123@email.com",
    "password": "segredo123"
}
```

Para que a aplicação consiga expor esse modelo na documentação, devemos criar uma classe do pydantic em nosso arquivo de schemas (`fast_zero/schemas.py`):

```python title="fast_zero/schemas.py" linenums="8"
class UserSchema(BaseModel):
    username: str
    email: str
    password: str
```

Agora que temos o status code configurado, temos que associar o modelo esperado na requisição com o endpoint. Para fazer isso basta que o endpoint receba um parâmetro e esse parâmetro esteja associado a um modelo via anotação de parâmetros:

```python title="fast_zero/app.py" hl_lines="6"
from fast_zero.schemas import Message, UserSchema

# Código do olá mundo homitido

@app.post('/users/', status_code=201)
def create_user(user: UserSchema):
    ...
```

Dessa forma o modelo de entrada, o que o endpoint espera receber já está documentado e aparecerá no swagger UI.

Para visualizar, temos que iniciar o servidor:

```shell title="$ Execução no terminal!"
task run
```

E acessar a página [http://127.0.01:8000/docs](http://localhost:8000/docs). Isso nos mostrará as definições do nosso endpoint usando o Swagger.

![descrição](assets/03/swagger_exibindo_o_schema_de_entrada_de_create_user.png){: .center }

#### Modelo de saída de dados
...

---

Com esse endpoint criado, podemos executar a nossa aplicação:

```shell title="$ Execução no terminal!"
task run
```

E acessar a página [http://localhost:8000/docs](http://localhost:8000/docs). Isso nos mostrará as definições do nosso endpoint usando o Swagger.

![descrição](assets/03/swagger.png){: .center }

Dessa forma, podemos testar de forma simplificada a nossa API, enviando o JSON e realizando alguns testes.

![descrição](assets/03/swagger_com_request.png){: .center }

Entretanto, precisamos prestar atenção a um detalhe: nosso modelo retorna a senha do usuário, o que é uma péssima prática de segurança.

![descrição](assets/03/respsota_do_swagger.png){: .center }

Para evitar isso, podemos criar um novo modelo que será usado somente para resposta. Dessa forma, não expomos os dados que não queremos na API:

```python title="fast_zero/schemas.py" linenums="10"
class UserPublic(BaseModel):
    username: str
    email: EmailStr
```

Precisamos também dizer ao FastAPI que esse será o modelo de resposta, e converter nosso `user` em `UserPublic`:


```python title="fast_zero/app.py" hl_lines="5"
from fast_zero.schemas import UserSchema, UserPublic

# código omitido

@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    return user
```

Note que somente adicionando o `response_model`, o FastAPI já faz a conversão de `UserSchema` em `UserPublic`

Agora, se fizermos de novo a chamada no Swagger, receberemos o mesmo objeto, mas sem expor a senha.

![descrição](assets/03/swagger_sem_senha.png){: .center }

### Criando um banco de dados falso

Finalmente, para brincar com essas rotas, podemos criar uma lista provisória para simular um banco de dados. Assim, podemos adicionar nossos dados e entender como o FastAPI funciona. Para isso, adicionamos uma lista provisória para o "banco" e alteramos nosso endpoint para inserir nossos modelos do Pydantic nessa lista:


```python title="fast_zero/app.py" hl_lines="5 10-14"
from fast_zero.schemas import UserSchema, UserPublic, UserDB

# código omitido

database = []  # provisório para estudo!


@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    user_with_id = UserDB(**user.model_dump(), id=len(database) + 1)

    database.append(user_with_id)

    return user_with_id
```

Se queremos uma simulação de banco de dados, precisamos ter um `ID` para cada usuário registrado no nosso "banco". Sendo assim, alteraremos nosso modelo de resposta pública (`UserPublic`) para que ele forneça o ID de criação do usuário. Também criaremos um novo modelo que represente o usuário com sua senha e identificador, que chamaremos de `UserDB`:

```python title="fast_zero/schemas.py" linenums="10"
class UserPublic(BaseModel):
    id: int
    username: str
    email: EmailStr


class UserDB(UserSchema):
    id: int
```

Dessa forma, nada muda. No entanto, podemos prosseguir com a construção dos outros endpoints. E lembre-se, é importante testar esse endpoint para garantir que tudo esteja funcionando corretamente.


### Implementando o teste da rota POST

Antes de criar o teste de fato, executaremos a task de teste para ver como anda a nossa cobertura:

```shell title="$ Execução no terminal!"
task test

# parte da resposta foi omitida

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      3    75%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      3    87%

# parte da resposta foi omitida
```

Vemos que temos 3 Miss. Possivelmente das linhas que acabamos de escrever.

![descrição](assets/03/cobertura_get_sem_testes.png){: .center }

Então, vamos escrever nosso teste. Esse teste para a rota POST precisa verificar se a criação de um novo usuário funciona corretamente. Enviamos uma solicitação POST com um novo usuário para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 201 (Criado) e se a resposta contém o novo usuário criado.

```python title="tests/test_app.py"
def test_create_user():
    client = TestClient(app)

    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    assert response.status_code == 201
    assert response.json() == {
        'username': 'alice',
        'email': 'alice@example.com',
        'id': 1,
    }
```

Ao executar o teste:

```shell title="$ Execução no terminal!"
task test

# parte da resposta foi omitida

tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      0   100%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      0   100%

# parte da resposta foi omitida
```

#### Não se repita (DRY)

Você deve ter notado que a linha `client = TestClient(app)` está repetida na primeira linha dos dois testes que fizemos. Repetir código pode tornar o gerenciamento de testes mais complexo à medida que cresce, e é aqui que o princípio de "Não se repita" ([DRY](https://pt.wikipedia.org/wiki/Don't_repeat_yourself){:target="_blank"}) entra em jogo. DRY incentiva a redução da repetição, criando um código mais limpo e manutenível.

Para solucionar essa repetição, podemos usar uma funcionalidade do pytest chamada Fixture. Uma fixture é como uma função que prepara dados ou estado necessários para o teste. Pode ser pensada como uma forma de não repetir a fase de Arrange de um teste, simplificando a chamada e não repetindo código.

??? info "Se fixtures são uma novidade para você"
	Existe uma live de Python onde discutimos especificamente sobre fixtures
	![type:video](https://www.youtube.com/embed/sidi9Z_IkLU)

	[:fontawesome-brands-youtube: Link direto ](https://youtu.be/sidi9Z_IkLU){ .md-button }


Neste caso, criaremos uma fixture que retorna nosso `client`. Para fazer isso, precisamos criar o arquivo `tests/conftest.py`. O arquivo `conftest.py` é um arquivo especial reconhecido pelo pytest que permite definir fixtures que podem ser reutilizadas em diferentes módulos de teste em um projeto. É uma forma de centralizar recursos comuns de teste.


```python title="tests/conftest.py"
import pytest
from fastapi.testclient import TestClient
from fast_zero.app import app

@pytest.fixture
def client():
    return TestClient(app)
```

Agora, em vez de repetir a criação do `client` em cada teste, podemos simplesmente passar a fixture como um argumento nos nossos testes:

```python title="tests/test_app.py"
# ...

def test_root_deve_retornar_200_e_ola_mundo(client):
    response = client.get('/')
	# ...

def test_create_user(client):
    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    # ...
```

Com essa simples mudança, conseguimos tornar nosso código mais limpo e fácil de manter, seguindo o princípio DRY.

---

Vemos que estamos no caminho certo. Agora que a rota POST está implementada, seguiremos para a próxima operação CRUD: Read.

## Implementando a Rota GET

A rota GET é usada para recuperar informações de um ou mais usuários do nosso sistema. No contexto do CRUD, o verbo HTTP GET está associado à operação "Read". Se a solicitação for bem-sucedida, a rota deve retornar o status HTTP 200 (OK).

Para estruturar a resposta dessa rota, podemos criar um novo modelo chamado `UserList`. Este modelo representará uma lista de usuários e contém apenas um campo chamado `users`, que é uma lista de `UserPublic`. Isso nos permite retornar múltiplos usuários de uma vez.

```python title="fast_zero/schemas.py" linenums="20"
class UserList(BaseModel):
    users: list[UserPublic]
```

Com esse modelo definido, podemos criar nosso endpoint GET. Este endpoint retornará uma instância de `UserList`, que por sua vez contém uma lista de `UserPublic`. Cada `UserPublic` é criado a partir dos dados de um usuário em nosso banco de dados fictício.

```python title="fast_zero/app.py"
from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList

# código omitido

@app.get('/users/', response_model=UserList)
def read_users():
    return {'users': database}
```

Com essa implementação, nossa API agora pode retornar uma lista de usuários. No entanto, nosso trabalho ainda não acabou. A próxima etapa é escrever testes para garantir que nossa rota GET está funcionando corretamente. Isso nos ajudará a identificar e corrigir quaisquer problemas antes de prosseguirmos com a implementação de outras rotas.

#### Implementando o teste da rota de GET

Nosso teste da rota GET tem que verificar se a recuperação dos usuários está funcionando corretamente. Enviamos uma solicitação GET para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contém a lista de usuários.

```python title="tests/test_app.py" linenums="30"
def test_read_users(client):
    response = client.get('/users/')
    assert response.status_code == 200
    assert response.json() == {
        'users': [
            {
                'username': 'alice',
                'email': 'alice@example.com',
                'id': 1,
            }
        ]
    }
```

Com as rotas POST e GET implementadas, agora podemos criar e recuperar usuários. Implementaremos a próxima operação CRUD: Update.

## Implementando a Rota PUT

A rota PUT é usada para atualizar as informações de um usuário existente. No contexto do CRUD, o verbo HTTP PUT está associado à operação "Update". Se a solicitação for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usuário solicitado não for encontrado, deveríamos retornar o status HTTP 404 (Não Encontrado).

```python title="fast_zero/app.py"
from fastapi import FastAPI, HTTPException

# ...

@app.put('/users/{user_id}', response_model=UserPublic)
def update_user(user_id: int, user: UserSchema):
    if user_id > len(database) or user_id < 1:
        raise HTTPException(status_code=404, detail='User not found')

    user_with_id = UserDB(**user.model_dump(), id=user_id)
    database[user_id - 1] = user_with_id

    return user_with_id
```

#### Implementando o teste da rota de PUT

Nosso teste da rota PUT precisa verificar se a atualização de um usuário existente funciona corretamente. Enviamos uma solicitação PUT com as novas informações do usuário para a rota `/users/{user_id}`. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contém o usuário atualizado.

```python title="tests/test_app.py"
def test_update_user(client):
    response = client.put(
        '/users/1',
        json={
            'username': 'bob',
            'email': 'bob@example.com',
            'password': 'mynewpassword',
        },
    )
    assert response.status_code == 200
    assert response.json() == {
        'username': 'bob',
        'email': 'bob@example.com',
        'id': 1,
    }
```

Com as rotas POST, GET e PUT implementadas, agora podemos criar, recuperar e atualizar usuários. A última operação CRUD que precisamos implementar é Delete.

## Implementando a Rota DELETE

A rota DELETE é usada para excluir um usuário do nosso sistema. No contexto do CRUD, o verbo HTTP DELETE está associado à operação "Delete". Se a solicitação for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usuário solicitado não for encontrado, deveríamos retornar o status HTTP 404 (Não Encontrado).

[TODO: Texto foi removido daqui, confirmar a continuidade]

Agora podemos criar nosso endpoint DELETE. Este endpoint receberá o ID do usuário que queremos excluir. Note que, estamos lançando uma exceção HTTP quando o ID do usuário está fora do range da nossa lista (simulação do nosso banco de dados). Quando conseguimos excluir o usuário com sucesso, retornamos a mensagem de sucesso em um modelo do tipo `Message`.

```python title="fast_zero/app.py"
from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList, Message

# ...

@app.delete('/users/{user_id}', response_model=Message)
def delete_user(user_id: int):
    if user_id > len(database) or user_id < 1:
        raise HTTPException(status_code=404, detail='User not found')

    del database[user_id - 1]

    return {'detail': 'User deleted'}
```

Com a implementação da rota DELETE concluída, é fundamental garantirmos que essa rota está funcionando conforme o esperado. Para isso, precisamos escrever testes para essa rota.

#### Implementando o teste da rota de DELETE

Nosso teste da rota DELETE precisa verificar se a exclusão de um usuário existente funciona corretamente. Enviamos uma solicitação DELETE para a rota /users/{user_id}. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contém uma mensagem informando que o usuário foi excluído.

```python title="tests/test_app.py"
def test_delete_user(client):
    response = client.delete('/users/1')

    assert response.status_code == 200
    assert response.json() == {'detail': 'User deleted'}
```

#### Checando tudo antes do commit

Antes de fazermos o commit, é uma boa prática checarmos todo o código, e podemos fazer isso com as ações que criamos com o taskipy.

```shell title="$ Execução no terminal!"
$ task lint
All done! ✨ 🍰 ✨
5 files would be left unchanged.

$ task format
All done! ✨ 🍰 ✨
5 files left unchanged.
Skipped 1 files

$ task test
...
tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED
tests/test_app.py::test_read_users PASSED
tests/test_app.py::test_update_user PASSED
tests/test_app.py::test_delete_user PASSED

---------- coverage: platform linux, python 3.11.4-final-0 -----------
Name                   Stmts   Miss  Cover
------------------------------------------
fastzero/__init__.py       0      0   100%
fastzero/app.py           28      2    93%
fastzero/schemas.py       15      0   100%
------------------------------------------
TOTAL                     43      2    95%


============================================ 5 passed in 1.48s =============================================
Wrote HTML report to htmlcov/index.html

```

## Commit

Após toda essa jornada de aprendizado, construção e teste de rotas, chegou a hora de registrar nosso progresso utilizando o git. Fazer commits regulares é uma boa prática, pois mantém um histórico detalhado das alterações e facilita a volta a uma versão anterior do código, se necessário.

Primeiramente, verificaremos as alterações feitas no projeto com o comando `git status`. Este comando nos mostrará todos os arquivos modificados que ainda não foram incluídos em um commit.

```shell title="$ Execução no terminal!"
git status
```

Em seguida, adicionaremos todas as alterações para o próximo commit. O comando `git add .` adiciona todas as alterações feitas em todos os arquivos do projeto.

```shell title="$ Execução no terminal!"
git add .
```

Agora, estamos prontos para fazer o commit. Com o comando `git commit`, criamos uma nova entrada no histórico do nosso projeto. É importante adicionar uma mensagem descritiva ao commit, para que, no futuro, outras pessoas ou nós mesmos entendamos o que foi alterado. Nesse caso, a mensagem do commit poderia ser "Implementando rotas CRUD".

```shell title="$ Execução no terminal!"
git commit -m "Implementando rotas CRUD"
```

Por fim, enviamos nossas alterações para o repositório remoto com `git push`. Se você tiver várias branches, certifique-se de estar na branch correta antes de executar este comando.

```shell title="$ Execução no terminal!"
git push
```

E pronto! As alterações estão seguras no histórico do git, e podemos continuar com o próximo passo do projeto.

## Conclusão

Com a implementação bem-sucedida das rotas CRUD, demos um passo significativo na construção de uma API robusta e funcional com FastAPI. Agora podemos manipular usuários - criar, ler, atualizar e excluir - o que é fundamental para muitos sistemas de informação.

O papel dos testes em cada etapa não pode ser subestimado. Testes não apenas nos ajudam a assegurar que nosso código está funcionando como esperado, mas também nos permitem refinar nossas soluções e detectar problemas potenciais antes que eles afetem a funcionalidade geral do nosso sistema. Nunca subestime a importância de executar seus testes sempre que fizer uma alteração em seu código!

Até aqui, no entanto, trabalhamos com um "banco de dados" provisório, na forma de uma lista Python, que é volátil e não persiste os dados de uma execução do aplicativo para outra. Para nosso aplicativo ser útil em um cenário do mundo real, precisamos armazenar nossos dados de forma mais duradoura. É aí que os bancos de dados entram.

No próximo tópico, exploraremos uma das partes mais críticas de qualquer aplicativo - a conexão e interação com um banco de dados. Aprenderemos a integrar nosso aplicativo FastAPI com um banco de dados real, permitindo a persistência de nossos dados de usuário entre as sessões do aplicativo.
